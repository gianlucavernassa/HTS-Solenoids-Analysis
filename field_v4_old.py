# -*- coding: utf-8 -*-
"""
Field and energy calculator for stack of pancakes
- v4 includes the calculation using Magpylib for single loop and series of pancakes
 included as a new class, Pancakes, based on magpylib collections

"""
# ----------------------------------------------
import numpy as np
import matplotlib.pyplot as plt

from scipy.special import ellipk
from scipy.special import ellipe
# from scipy.io import savemat
from matplotlib.patches import Rectangle
from matplotlib.collections import LineCollection
import matplotlib as mpl

import magpylib as my
# import plotly.graph_objs as go
# import plotly.io as io
# ----------------------------------------------

# formulas

def find_nearest(array, value):
    # find element in array closest to a value
    
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return idx, array[idx]

def Field_ring_at_point(rc, I, point):
    """
    Radial and axial fields at a point in space generated by a current loop.
    based on equations 5.69 and 5.70 of Russenschuck's book.

    Parameters
    ----------
    rc : float
        current loop radius 
    I : float
        Current running in the loop.
    point : array
        R, (Y), and Z coordinates of the point

    Returns
    -------
    Br : float
        Radial field contribution at point.
    Bz : float
        Axial field contribution at point.
    """
    
    mu0 = 4*np.pi*(1e-7)

    xp = point[0]
    yp = point[1]
    zp = point[2]
    
    rp = np.sqrt(xp**2+yp**2+zp**2)     # distance from origin == centre of ring
    
    kk = np.sqrt((4*rp*rc)/((rp+rc)**2+zp**2))  # modulus k for elliptic integrals
    
    # eq. 5.69 and 5.70
    Br = (mu0*I)/(2*np.pi*rp)* zp/np.sqrt((rp+rc)**2+zp**2) * (-ellipk(kk) + (rc**2 + rp**2 + zp**2)/((rc-rp)**2+zp**2)*ellipe(kk)) 
    Bz = (mu0*I) / (2*np.pi)/np.sqrt((rp+rc)**2+zp**2) *(ellipk(kk) + (rc**2-rp**2-zp**2)/((rc-rp)**2+zp**2)*ellipe(kk))    
    
    
    return Br, Bz

def Field_ring_on_grid(rc, I, R, Z):
    """
    Extension of previous formula for computing radial and axial fields 
    generated by a current loop on a 2D grid of points.
    based on equations 5.69 and 5.70 of Russenschuck's book.

    Parameters
    ----------
    rc : float
        current loop radius 
    I : float
        Current running in the loop.
    R : 2D mesh array
        Radial mesh array. R coordinates only varying through columns.
    Z : 2D mesh array
        Axial mesh array. Z coordinates only varying through rows.
    
    Returns
    -------
    Br : 2D array
        Radial field on the grid defined by R x Z.
    
    Bz : 2D array
        Axial field on the grid defined by R x Z.
    """
    mu0 = 4*np.pi*(1e-7)
    
    DIST = (R**2 + Z**2)**0.5  # matrix of distances from origin == centre of ring
    
    KK = (4*DIST*rc/((DIST+rc)**2+Z**2))**0.5   # Matrix of k moduli for elliptic integrals
    
    # eq. 5.69 and 5.70
    Br = (mu0*I)/(2*np.pi*DIST)* Z/np.sqrt((DIST+rc)**2+ Z**2) * (-ellipk(KK) + (rc**2 + DIST**2 + Z**2)/((rc-DIST)**2+Z**2)*ellipe(KK)) 
    Bz = (mu0*I) / (2*np.pi)/np.sqrt((DIST+rc)**2+Z**2) *(ellipk(KK) + (rc**2-DIST**2-Z**2)/((rc-DIST)**2+Z**2)*ellipe(KK))    
    return Br, Bz


def INDUCTANCE(am, L, N):
    # eq. 86 of Rosa and Grover's formulas report.
    mu0 = 4*np.pi*1e-7
    RR = 0.2235*(am+L)
    
    induct = am*N**2*mu0*(np.log(8*am/RR)*(1+3*RR**2/16/am**2)-(2+RR**2/16/am**2))  
    return induct


def field_calc(Npancakes, Nturns, gap, 
               Je, tape_w, tape_t, Rin, 
               v_divi, h_divi, Nx, Ny, pti_line, 
               calculate_grid = 1, calculate_line = 1, least_square_fit = 0):
    """
    This function computes the magnetic field generated by a series of solenoids,
    made up of tape-shape conductiors, considering them as current loops. 
    The single field computation is based on elliptic integrals as defined in 
    Field_ring_on_grid

    Parameters
    ----------
    Npancakes : int
        Number of stacked pancakes.
    Nturns : int
        Number of turns per pancake.
    gap : float
        Axial gap between consecutive pacakes.
    Je : float
        Engineering current density  A/mm^2.
    tape_w : float
        tape axial width.
    tape_t : float
        tape radial thinkness
    Rin : float
        Internal radius of the pancake.
    v_divi : int
        Discretization intervals in axial direction per tape
    h_divi : int
        Discretization intervals in radial direction per coil
    Nx : int
        Number of grid points in radial direction.
    Ny : int
        Number of grid points axially.
    pti_line : int
        Number of discretization points radially for the plot on graph.
    calculate_grid : Boolean (0,1), optional
        Flag to define if to calculate on grid or not. The default is 1.
    calculate_line : Boolean (0,1), optional
        Flag to define if to calculate on line or not. The default is 1.
    least_square_fit : Boolean (0,1), optional
        Decides whether to perform linear fit with least squares or by taking the net
        drop between internal and external radius.

    Returns
    -------
    r_sour : 1D array.
        Array containing radial coordinates of source points.
    z_sour : 1D array.
        Array containing axial coordinates of source points.
    R : 2D mesh array,
        Mesh matrix containing radial coordinates.
    Z : 2D mesh array,
        Mesh matrix containing axial coordinates.
    Br :2D mesh array,
        Mesh matrix containing Radial field values.
    Bz : 2D mesh array,
        Mesh matrix containing Axial field values.
    Bint :  2D mesh array,
        Mesh matrix containing field magnitude values.
    ind : float
        Inductance analytically computed.
    r_c_lines : 1D array,
        Radial coordinates of the points for line graphs.
    z_c_lines : 1D array,
        Axial coordinates of the evaluation lines, starting from the bottom ([0]),
        to the top ([Npancake])
    pp : 1D array
        Contains the coefficient of the polynomial fit, according to 
        B(r) = pp[0]*r + pp[1] 
        B(r) = B0 - C0*r
    Br_lines : 2D array,
        Contains the values of the radial field across the width of the pancake (columns),
        for the (row) pancake.
    Bz_lines : 2D array,
        Contains the values of the axial field across the width of the pancake (columns),
        for the (row) pancake.
    Bint_lines : 2D array,
        Contains the values of the field intensity across the width of the pancake (columns),
        for the (row) pancake.

    """
    mm = 1e-3
    extra_x = tape_w
    extra_z = tape_w

    # Dependend parameters and arrays
    I = Je*tape_w*tape_t/mm/mm
    I_i = I/v_divi*Nturns/h_divi # current at each source point

    mean_r = Rin + Nturns/2*tape_t # coil mean radius (for inductance)
    width_block = Npancakes*tape_w + (Npancakes-1)*gap
    total_turns = Npancakes*Nturns

    # grid of evaluation points
    offst_z = -(Npancakes*tape_w + (Npancakes-1)*gap)/2
    rr = np.linspace(0.0, Rin+Nturns*tape_t + extra_x, Nx)
    zz = np.linspace(offst_z - extra_z, -offst_z + extra_z, Ny)
    R, Z = np.meshgrid(rr,zz)
    dist = (R**2 + Z**2)**(0.5)

    # radial and axial coordinates of field source points
    r_sour = np.linspace(Rin+tape_t/2, Rin + tape_t*(2*Nturns-1)/(2) , h_divi)
    z_sour = np.zeros(v_divi*Npancakes)
    for ii in range(Npancakes):
        z_sour[ii*v_divi:(ii+1)*v_divi] = offst_z + ii*(tape_w+gap) + np.linspace(tape_w/v_divi/2, tape_w - tape_w/v_divi/2 , v_divi)

    # radial and axial coordinates of evaluation lines (midplanes of coils)
    r_c_lines = np.linspace(Rin, Rin + tape_t*Nturns, pti_line)
    z_c_lines = np.array([offst_z+tape_w/2])
    if Npancakes != 1:
        for ss in range(1, Npancakes):
            z_c_lines = np.append(z_c_lines, offst_z + tape_w/2 + ss*(tape_w+gap))

    R_c_lines, Z_c_lines = np.meshgrid(r_c_lines, z_c_lines)

    print('Grid sources: ', h_divi*v_divi*Npancakes)
    print('Grid calc. points: ', Nx*Ny)

    # inductance calculation
    ind = INDUCTANCE(mean_r, width_block, total_turns)
    # Energy stored
    Um = 1/2 * ind * I**2
    print('Inductance of c.a.:', np.round(ind*1e3,3), ' mH')
    print('Stored magnetic energy:', np.round(Um*1e-3,3), ' kJ')


    Br = np.zeros([Ny, Nx])
    Bz = np.zeros([Ny, Nx])

    Br_lines = np.zeros([Npancakes, pti_line])
    Bz_lines = np.zeros([Npancakes, pti_line])

    for ii, rc in enumerate(r_sour):
        # iterate over tapes radii
        for jj, zc in enumerate(z_sour):
            # for each radius, iterate on the z-coordinates
            # but we correct the "zero" Z coordinate 

            if calculate_grid == 1:
                Zmod = Z - zc # offsetting grid with respect to ring centre
                Br = Br + Field_ring_on_grid(rc, I_i, R, Zmod)[0]
                Bz = Bz + Field_ring_on_grid(rc, I_i, R, Zmod)[1]

            if calculate_line == 1:
                Z_line_mod = Z_c_lines - zc # offsetting lines with respect to ring centre
                Br_lines = Br_lines + Field_ring_on_grid(rc, I_i, R_c_lines, Z_line_mod)[0]
                Bz_lines = Bz_lines + Field_ring_on_grid(rc, I_i, R_c_lines, Z_line_mod)[1]

    Bint = (Br**2+Bz**2)**(0.5)
    Bint_lines = (Br_lines**2+Bz_lines**2)**0.5

    Bmax = np.max([np.max(Bint), np.max(Bint_lines)])
    print('Peak field of: ', np.round(Bmax,2), ' T')
    idx00 = find_nearest(zz, 0.0)[0]
    print('Axial bore field of c.a.: ', np.round(Bz[idx00,0],2), ' T')


    # Linearization of field along midplane
    pp = np.zeros([Npancakes,2])

    for ss in range(Npancakes):
        if least_square_fit ==1:
            pp[ss,:] = np.polyfit(r_c_lines, Bz_lines[ss,:], 1)
        else:
            r1 = r_c_lines[0]
            r2 = r_c_lines[-1]
            B1 = Bz_lines[ss,0]
            B2 = Bz_lines[ss,-1]

            pp[ss,0] = -(B1-B2)/(r2-r1)
            pp[ss,1] = B1 + (B1-B2)/(r2-r1)*r1

    for ss in range(Npancakes):
        print('Pancake n. {}, B0: {} T, C0: {} T/m'.format(int(ss+1), np.round(pp[ss,1],1), - np.round(pp[ss,0])))
    
    print('\n Calculation completed.')
    return r_sour, z_sour, R, Z, Br, Bz, Bint, ind, r_c_lines, z_c_lines, pp, Br_lines, Bz_lines, Bint_lines


def field_calc_keypoints(Npancakes, Nturns, gap, 
               Je, tape_w, tape_t, Rin, 
               v_divi, h_divi, pti_line_v = 2, pti_line_h = 3, 
               calculate_line_v = 1, calculate_line_h = 1):
    # """
    # This function computes the magnetic field generated by a series of solenoids,
    # made up of tape-shape conductiors, considering them as current loops. 
    # The single field computation is based on elliptic integrals as defined in 
    # Field_ring_on_grid

    # Parameters
    # ----------
    # Npancakes : int
    #     Number of stacked pancakes.
    # Nturns : int
    #     Number of turns per pancake.
    # gap : float
    #     Axial gap between consecutive pacakes.
    # Je : float
    #     Engineering current density  A/mm^2.
    # tape_w : float
    #     tape axial width.
    # tape_t : float
    #     tape radial thinkness
    # Rin : float
    #     Internal radius of the pancake.
    # v_divi : int
    #     Discretization intervals in axial direction per tape
    # h_divi : int
    #     Discretization intervals in radial direction per coil
    # Nx : int
    #     Number of grid points in radial direction.
    # Ny : int
    #     Number of grid points axially.
    # pti_line : int
    #     Number of discretization points radially for the plot on graph.
    # calculate_grid : Boolean (0,1), optional
    #     Flag to define if to calculate on grid or not. The default is 1.
    # calculate_line : Boolean (0,1), optional
    #     Flag to define if to calculate on line or not. The default is 1.
    # least_square_fit : Boolean (0,1), optional
    #     Decides whether to perform linear fit with least squares or by taking the net
    #     drop between internal and external radius.

    # Returns
    # -------
    # r_sour : 1D array.
    #     Array containing radial coordinates of source points.
    # z_sour : 1D array.
    #     Array containing axial coordinates of source points.
    # R : 2D mesh array,
    #     Mesh matrix containing radial coordinates.
    # Z : 2D mesh array,
    #     Mesh matrix containing axial coordinates.
    # Br :2D mesh array,
    #     Mesh matrix containing Radial field values.
    # Bz : 2D mesh array,
    #     Mesh matrix containing Axial field values.
    # Bint :  2D mesh array,
    #     Mesh matrix containing field magnitude values.
    # ind : float
    #     Inductance analytically computed.
    # r_c_lines : 1D array,
    #     Radial coordinates of the points for line graphs.
    # z_c_lines : 1D array,
    #     Axial coordinates of the evaluation lines, starting from the bottom ([0]),
    #     to the top ([Npancake])
    # pp : 1D array
    #     Contains the coefficient of the polynomial fit, according to 
    #     B(r) = pp[0]*r + pp[1] 
    #     B(r) = B0 - C0*r
    # Br_lines : 2D array,
    #     Contains the values of the radial field across the width of the pancake (columns),
    #     for the (row) pancake.
    # Bz_lines : 2D array,
    #     Contains the values of the axial field across the width of the pancake (columns),
    #     for the (row) pancake.
    # Bint_lines : 2D array,
    #     Contains the values of the field intensity across the width of the pancake (columns),
    #     for the (row) pancake.

    # """
    
    # Dependend parameters and arrays
    mm = 1e-3
    I = Je*tape_w*tape_t/mm/mm
    I_i = I/v_divi*Nturns/h_divi # current at each source point
    
    dist_vline = tape_t

    mean_r = Rin + Nturns/2*tape_t # coil mean radius (for inductance)
    width_block = Npancakes*tape_w + (Npancakes-1)*gap
    total_turns = Npancakes*Nturns

    # grid of evaluation points
    offst_z = -(Npancakes*tape_w + (Npancakes-1)*gap)/2  # z-location of bottom layer
    
    # radial and axial coordinates of field source points
    r_sour = np.linspace(Rin+tape_t/2, Rin + tape_t*(2*Nturns-1)/(2) , h_divi)
    z_sour = np.zeros(v_divi*Npancakes)
    for ii in range(Npancakes):
        z_sour[ii*v_divi:(ii+1)*v_divi] = offst_z + ii*(tape_w+gap) + np.linspace(tape_w/v_divi/2, tape_w - tape_w/v_divi/2 , v_divi)

    # radial and axial coordinates of evaluation lines (midplanes of central coil)
    r_hline = np.linspace(Rin-tape_t, Rin + tape_t*Nturns+tape_t, pti_line_h)
    if Npancakes%2 == 0:
        z_hline = np.array([gap+tape_w])/2
    else:
        z_hline = np.array([0])
        
    R_hline, Z_hline = np.meshgrid(r_hline, z_hline)
    
    r_vline = np.array([Rin- dist_vline])
    z_vline = np.linspace(-offst_z-tape_w, -offst_z, pti_line_v)
           
    R_vline, Z_vline = np.meshgrid(r_vline, z_vline)

    print('Grid sources: ', h_divi*v_divi*Npancakes)

    # inductance calculation
    ind = INDUCTANCE(mean_r, width_block, total_turns)
    # Energy stored
    Um = 1/2 * ind * I**2
    print('Inductance of c.a.:', np.round(ind*1e3,3), ' mH')
    print('Stored magnetic energy:', np.round(Um*1e-3,3), ' kJ')

    Br_hline = np.zeros([1, pti_line_h])
    Bz_hline = np.zeros([1, pti_line_h])
    
    Br_vline = np.zeros([1, pti_line_v])
    Bz_vline = np.zeros([1, pti_line_v])
    
    B_bore = 0.0
    
    for ii, rc in enumerate(r_sour):
        # iterate over tapes radii
        for jj, zc in enumerate(z_sour):
            # for each radius, iterate on the z-coordinates
            # but we correct the "zero" Z coordinate 
            
            B_bore = B_bore + Field_ring_at_point(rc, I_i, [0.0, 0.0, -zc])[1]
            if calculate_line_h == 1:
                Z_line_mod = Z_hline - zc # offsetting lines with respect to ring centre
                Br_hline = Br_hline + Field_ring_on_grid(rc, I_i, R_hline, Z_line_mod)[0]
                Bz_hline = Bz_hline + Field_ring_on_grid(rc, I_i, R_hline, Z_line_mod)[1]
            
            if calculate_line_v == 1:
                Z_line_mod = Z_vline - zc # offsetting lines with respect to ring centre
                Br_vline = Br_vline + Field_ring_on_grid(rc, I_i, R_vline, Z_line_mod)[0]
                Bz_vline = Bz_vline + Field_ring_on_grid(rc, I_i, R_vline, Z_line_mod)[1]

    Bint_hline = (Br_hline**2+Bz_hline**2)**0.5
    Bint_vline = (Br_vline**2+Bz_vline**2)**0.5

    Bmax = np.max([np.max(Bint_hline), np.max(Bint_vline)])
    print('Peak field of: ', np.round(Bmax,2), ' T')
    print('Bore field of: ', np.round(B_bore,2), ' T')
    
    # Linearization of field along single coil midplane
    pp = np.zeros([2])

    r1 = r_hline[0]
    r2 = r_hline[-1]
    B1 = Bz_hline[0,0]
    B2 = Bz_hline[0,-1]
    pp[0] = -(B1-B2)/(r2-r1)
    pp[1] = B1 + (B1-B2)/(r2-r1)*r1

    print('Pancake n. {}, B0: {} T, C0: {} T/m'.format((int(Npancakes+1)//2), np.round(pp[1],1), - np.round(pp[0])))
    
    print('\n Calculation completed.')
    return r_sour, z_sour, ind, B_bore, pp, r_hline, z_hline, Br_hline, Bz_hline, r_vline, z_vline, Br_vline, Bz_vline

# plot of points and grid 
def plot_grid(Npancakes, Rin, tape_w, tape_t, Nturns, gap, R,Z, r_sour, z_sour, r_c_lines, z_c_lines):
    """
    Produces plot of source points and evaluation grid.

    Parameters
    ----------
    Npancakes : int
        Number of stacked pancakes.
    Rin : float
        Internal radius of the pancake.
    tape_w : float
        tape axial width.
    tape_t : float
        tape radial thinkness
    Nturns : TYPE
        DESCRIPTION.
    gap : float
        Axial gap between consecutive pacakes.
    R : 2D mesh array,
        Mesh matrix containing radial coordinates.
    Z : 2D mesh array,
        Mesh matrix containing axial coordinates.
    r_sour : 1D array.
        Array containing radial coordinates of source points.
    z_sour : 1D array.
        Array containing axial coordinates of source points.
    r_c_lines : 1D array,
        Radial coordinates of the points for line graphs.
    z_c_lines : 1D array,
        Axial coordinates of the evaluation lines, starting from the bottom ([0]),
        to the top ([Npancake])

    Returns
    -------
    fig : Matplotlib figure
    ax : Matplotlib axes

    """
    mm = 1e-3
    offst_z = -(Npancakes*tape_w + (Npancakes-1)*gap)/2
    fig, ax = plt.subplots(figsize = [5,4], dpi = 300)
    ax.scatter(R, Z, 0.7, 'k', '.')

    segs1 = np.stack((R,Z), axis=2)
    segs2 = segs1.transpose(1,0,2)
    plt.gca().add_collection(LineCollection(segs1, linewidth = 0.25, color = 'black'))
    plt.gca().add_collection(LineCollection(segs2, linewidth = 0.25, color = 'black'))

    sourcX, sourcY = np.meshgrid(r_sour,z_sour)

    ax.scatter(sourcX, sourcY, 0.5, 'r', '.')

    for ss in range(Npancakes):
        ax.add_patch(Rectangle((Rin,offst_z+ss*(tape_w+gap)), 
                               width = Nturns*tape_t, height = tape_w, 
                               fc=(0,0,0,0), ec=(1,0,0,1))) #, hatch='|||||'))
        ax.plot(r_c_lines, z_c_lines[ss]*np.ones_like(r_c_lines), 'b')
        t = ax.annotate('P. {}'.format(int(ss+1)), (r_c_lines[-1] + tape_w/3, z_c_lines[ss]), fontsize = 6)
        t.set_bbox(dict(facecolor='white'))
        
    plt.tick_params(
        axis='both',
        which='both',
        bottom=False,
        top=False,
        left = False,
        right = False,
        labelbottom=False, 
        labeltop = False,
        labelleft = False,
        labelright = False)

    ax.set_title('Calculation points')
    ax.axis('equal')
    ax.set_xlim([-0.001, np.max(R)*1.02])
    
    return fig, ax

def plot_sources(ax, r_sour, z_sour):
    
    sourcX, sourcY = np.meshgrid(r_sour,z_sour)
    ax.scatter(sourcX, sourcY, 0.5, 'r', '.')
        
    plt.tick_params(
        axis='both',
        which='both',
        bottom=False,
        top=False,
        left = False,
        right = False,
        labelbottom=False, 
        labeltop = False,
        labelleft = False,
        labelright = False)

    ax.axis('equal')
    
    return 


def plot_lines(ax, r_hline, z_hline, r_vline, z_vline):
    
    ax.plot(r_hline, z_hline*np.ones_like(r_hline), 'k')
    ax.plot(r_vline*np.ones_like(z_vline), z_vline, 'k')
        
    plt.tick_params(
        axis='both',
        which='both',
        bottom=False,
        top=False,
        left = False,
        right = False,
        labelbottom=False, 
        labeltop = False,
        labelleft = False,
        labelright = False)

    ax.axis('equal')
    
    return 

def intensity_plot(Npancakes, Nturns, Je, Rin, tape_w, tape_t, gap, R,Z, Br, Bz, figsiz, figdpi = 400):
    mm = 1e-3
    I = Je*tape_w*tape_t/mm/mm
    print(I)
    offst_z = -(Npancakes*tape_w + (Npancakes-1)*gap)/2
    rr = R[0,:]
    zz = Z[:,0]
    
    Nx = np.shape(R)[1]
    Ny = np.shape(R)[0]
    
    spec_r = np.concatenate((-np.flip(rr, axis = 0),rr[1::]))
    R_ext, Z_ext = np.meshgrid(spec_r, zz)

    # Creiamo nuove matrici Br e Bz per coprire due quadranti
    Br_extended = np.zeros((Ny, 2*Nx-1))
    Bz_extended = np.zeros((Ny, 2*Nx-1))

    Br_extended[:, :Nx] = -np.fliplr(Br)
    Br_extended[:, Nx:] = Br[:,1:]

    Bz_extended[:, :Nx] = np.fliplr(Bz)
    Bz_extended[:, Nx:] = Bz[:,1:]

    spec_B_int = (Bz_extended**2+Br_extended**2)**(0.5)
        
    fig,ax = plt.subplots(figsize = figsiz, dpi = figdpi)
    sc = ax.scatter(R_ext,Z_ext, 2, c = spec_B_int, marker ='s', cmap = 'RdYlBu_r')
    for ss in range(Npancakes):
        ax.add_patch(Rectangle((Rin,offst_z+ss*(tape_w+gap)), width = Nturns*tape_t, height = tape_w, fc=(0,0,0,0), ec=(0,0,0,1), hatch='|||||'))
        ax.add_patch(Rectangle((-Rin-Nturns*tape_t,offst_z+ss*(tape_w+gap)), width = Nturns*tape_t, height = tape_w, fc=(0,0,0,0), ec=(0,0,0,1), hatch='|||||'))
    plt.colorbar(sc)
    ax.streamplot(R_ext, Z_ext, Br_extended, Bz_extended, density = 0.91, color = 'k', linewidth = 0.8)
    ax.axis('equal')
    ax.set_title('Field intensity \n {} pancake(s), {} mm thick, {} turns, I = {} A'.format(Npancakes, round(tape_w/mm), Nturns, round(I)))
    ax.set_xlim([np.min(spec_r)*1.05, np.max(spec_r)*1.05])
    
    plt.tick_params(
        axis='both',
        which='both',
        bottom=False,
        top=False,
        left = False,
        right = False,
        labelbottom=False, 
        labeltop = False,
        labelleft = False,
        labelright = False)
    
    return fig,ax

# Plot field along midplanes
def midplanes_plot(Npancakes, pp, r_c_lines, z_c_lines, Br_lines, Bz_lines, figsiz = [6,6], figdpi = 400, colmap = 'plasma'):
    """
    Produces plot of field along midplanes of pancakes and numerates the from 1 to Npancake
    starting from the bottom one.

        
    Parameters
    ----------
    Npancakes : int
        Number of stacked pancakes.
    pp : 1D array
        Contains the coefficient of the polynomial fit, according to 
        B(r) = pp[0]*r + pp[1] 
        B(r) = B0 - C0*r

    r_c_lines : 1D array,
        Radial coordinates of the points for line graphs.
    z_c_lines : 1D array,
        Axial coordinates of the evaluation lines, starting from the bottom ([0]),
        to the top ([Npancake])
    Br_lines : 2D array,
        Contains the values of the radial field across the width of the pancake (columns),
        for the (row) pancake.
    Bz_lines : 2D array,
        Contains the values of the axial field across the width of the pancake (columns),
        for the (row) pancake.
    figsiz : [1x2 array], optional
        Figure size in inches. The default is [6,6].
    figdpi : int, optional
        Figure pixels per inc. The default is 400.
    colmap : String, optional
        Matplotlib colormap. The default is 'plasma'.

    Returns
    -------
    fig : TYPE
        DESCRIPTION.
    ax : TYPE
        DESCRIPTION.

    """
    mm = 1e-3
    # --------- Graphics --------------
    contours = Npancakes
    divisions = np.linspace(0,1, contours)
    cmap = mpl.colormaps.get_cmap('plasma')
    # ---------------------------------

    fig, ax = plt.subplots(figsize = figsiz, dpi = figdpi)
    for ss in range(Npancakes):
        colore = cmap(divisions[ss])
        if ss < Npancakes/2 :
            ax.plot(r_c_lines*1e3, Bz_lines[ss,:], 
                    label = 'pancake {}'.format(int(ss+1)), 
                    color = colore)
            ax.plot(r_c_lines*1e3, np.polyval(pp[ss,:], r_c_lines), '--', 
                    label = 'fit pan.  {}'.format(int(ss+1)),
                    color = colore)
        else:
            ax.plot(r_c_lines*1e3, Bz_lines[ss,:], 'x', 
                    label = 'pancake {}'.format(int(ss+1)), 
                    color = colore)

    ax.grid()
    ax.grid(visible=True, which='minor', axis='both', alpha = 0.1)
    ax.minorticks_on()
        
    ax.set_title('Field along coil midplane(s)')
    ax.set_ylabel(r'B$_z$ / T')
    ax.set_xlabel(r'r / mm')
    ax.legend()
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
    ax.legend(fontsize = 8, loc='center left', bbox_to_anchor=(1, 0.5))
    
    return fig, ax




def field_magpy(current, radius, grid, position = (0.0, 0.0, 0.0), axis = (0.0, 0.0, 1.0)):
    """
    Function to compute the field using the magpy library. 
    This function, as described in https://doi.org/10.3390/magnetism3010002, is numerically stable and computationally efficient.

    All parameters in input MUST BE IN SI UNITS.
    ----------
    current : float
        Value of the current running through the ring.
    radius : floa
        radius of the ring current.
    grid : (N × M × 3) numpy array 
        Array containing the coordinates of the points for which the field must be calculated.
        Usually defined with np.array([[(x, 0.0, z) for x in X] for z in Z])
    position : TYPE, optional
        DESCRIPTION. The default is (0.0, 0.0, 0.0).
    axis : TYPE, optional
        DESCRIPTION. The default is (0.0, 0.0, 1.0).

    Returns
    -------
    BT : (N × M × 3) numpy array
        Computed field (in Tesla).

    """
    
    mm = 1.0e-3
    mT = 1.0e-3
    diam_mm = 2*radius/mm
    grid_mm = grid/mm
    
    ring = my.current.Circle(position=position, diameter=diam_mm, current = current, orientation = None)
    
    B = my.getB(ring, grid_mm)
    BT = B*mT
    
    return BT

class Pancakes(my.Collection):
    # Now introducing SI units
    
    def __init__(self, I = 1.0, radius = 0.001, rows = 2, columns = 3, 
                 dr = 0.001, dz = 0.001, offset_z = None, Npancakes = 1, gap = 0.001, **kwargs):
        """
        Defines a MagPy class of collection of field sources.
        The class defined hereby requires SI units, as these will subsequently be converted to 'mm'
        as required by magpy v4.5.1.
        
        Parameters
        ----------
        I : float, optional
            Current. Default is 1 A.
        radius : float, optional
            Bore radius of the magnet. The default is 5.0.
        rows : float, optional
            number of discretization points per tape vertically. The default is 2.
        columns : float, optional
            Number of discretization points per coil section horizontally. The default is 3.
        dr : float, optional
            Spacing between discretization points horizontally. The default is 1.
        dz : float, optional
            Spacing between discretization points vertically. The default is 1.
        offset_z : float, optional
            Offset value of the initial z-coordinate of the first pankace. Values <0 would shift downwards. The default is None.
        Npancakes : int, optional
            Number of pancakes of this group. The default is 1.
        gap : float, optional
            axial gap between consecutive pancakes. The default is 1.0 
        
        **kwargs.

        """
        
        # conversion to mm
        radius_mm = radius*1.0e3
        gap_mm = gap*1.0e3
        dr_mm = dr*1.0e3
        dz_mm = dz*1.0e3
        
        coil_thick_mm = dz_mm * rows
        
        super().__init__(**kwargs)
        
        if not offset_z:
            # if no offset is required by the user, computes the negative offset of the first (from the bottom) coil.
            offset_z_mm = -(Npancakes/2.0)*coil_thick_mm - gap_mm*(Npancakes-1)/2.0
        else:
            # if the offset has been given by the user, it must have been in SI units, therefore we convert it here in 'mm'
            offset_z_mm = offset_z*1.0e3
            
        self._update(I, radius_mm, rows, columns, dr_mm, dz_mm, offset_z_mm, Npancakes, gap_mm)
    
    def _update(self, I, radius_mm, rows, columns, dr_mm, dz_mm, offset_z_mm, Npancakes, gap_mm):
    # Here, units are those of the magpylib ! as we have already passed (see init) the values in mm
                    
        # assigns the attribute _rows
        self._I = I
        self._radius = radius_mm
        self._rows = rows
        self._columns = columns
        
        # Clean up old object properties
        self.reset_path()
        self.children = []
        self.style.model3d.data.clear()
        
        pan_height_mm = rows*dz_mm
        
        # Add childrens
        for k in range(Npancakes):
            for j in range(columns):
                for i in range(rows):
                    
                    child = my.current.Circle(position = (0.0, 0.0, offset_z_mm + k*(gap_mm+pan_height_mm) + dz_mm/2 + i*dz_mm),
                                              diameter = 2*radius_mm + dr_mm + j*dr_mm*2.0, current = I)
                    self.add(child)
        
        # Re-apply path
        # self.position = (0.0, 0.0, 0.0)
        
        return self
    

def field_pancakes_magpy(grid, current, radius, Npancakes, gap, rows, columns, dr, dz, offset_z= 0.0, return_sources = None):
    
    collection = Pancakes(current, radius, 
                    rows = rows, columns = columns,
                    dr = dr, dz = dz,
                    Npancakes=Npancakes, gap = gap,
                    offset_z= offset_z)
    
    grid_mm = grid*1.0e3
    
    B = my.getB(collection, grid_mm)
    BT = B*1.0e-3
    
    if return_sources:
        sourc = np.empty([1,2])
        for i, ci in enumerate(collection.sources):
            diam_mm = ci.diameter
            z_mm = ci.position[2]
            r_z_SI = np.array([diam_mm/2, z_mm])*1.0e-3
            
            sourc = np.vstack((sourc, r_z_SI))
        
        return BT, sourc
    else:
        return BT
    
def field_pancakes_magpy_divided(grid, current, radius, Npancakes, gap, rows, columns, dr, dz, offset_z= None, return_sources = None):
    """
    This function subdivides the computation per each pancake, preventing excessive usage of RAM.
    Careful with this formula. I have noticed it is very delicate and subject sometimes to numeric cancellation.
    Manipulation of intermediate results should be kept to a minimum!

    Parameters
    ----------
    grid : (N × M × 3) numpy array 
        Array containing the coordinates of the points for which the field must be calculated.
        Usually defined with np.array([[(x, 0.0, z) for x in X] for z in Z])
    current : float
        Current.
    radius : float, optional
        Bore radius of the magnet.
    Npancakes : int, optional
        Number of pancakes of this group.
    gap : float, optional
        axial gap between consecutive pancakes.
    rows : float, optional
        number of discretization points per tape vertically.
    columns : float, optional
        Number of discretization points per coil section horizontally.
    dr : float, optional
        Spacing between discretization points horizontally.
    dz : float, optional
        Spacing between discretization points vertically.
    offset_z : float, optional
        Offset in Z of the centreline of the first pancake. The default is None.
    return_sources : Logic, optional
        Decides whether to return a 2D array containing the coordinates of source points. The default is None.

    Returns
    -------
    BT: (N × M × 3) numpy array 
        Field in Tesla computed on the grid passed.
    sourc: (rows*columns*Npacakes x 2) numpy array, optional controlled by return_sources
        Source current loop radial and axial coordinates in SI units.

    """
    
    grid_mm = grid*1.0e3
    B = np.ones_like(grid_mm)
    
    p_counter = 0
    
    if not offset_z:
        offset_z = -(Npancakes)/2*(dz*rows) - (Npancakes-1)*gap/2
    
    if return_sources:
        sourc = np.empty([1,2])
    
    for nn in range(Npancakes):
        
        offz_i = offset_z + nn*(gap+dz*rows)
        
        collection = Pancakes(current, radius, 
                        rows = rows, columns = columns,
                        dr = dr, dz = dz,
                        Npancakes=1, gap = gap,
                        offset_z= offz_i)
        
        Bi = my.getB(collection, grid_mm)
        
        
        B += Bi
        p_counter += 1
                
        if return_sources:
            for i, ci in enumerate(collection.sources):
            
                diam_mm = ci.diameter
                z_mm = ci.position[2]
                r_z_SI = np.array([diam_mm/2, z_mm])*1.0e-3
                
                
                if i == 0 and int(p_counter) == 1:
                    sourc[0] = r_z_SI 
                else:
                    sourc = np.vstack((sourc, r_z_SI))
    
    BT = B*1.0e-3
    
    if return_sources:
        return BT, sourc
    else:
        return BT